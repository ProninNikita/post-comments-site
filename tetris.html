<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–¢–µ—Ç—Ä–∏—Å</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0a0f;
            --grid: #1a1a24;
            --border: #2a2a3a;
            --cyan: #00f5ff;
            --cyan-dim: #00b4c5;
            --yellow: #ffea00;
            --purple: #bf00ff;
            --green: #00ff88;
            --red: #ff3366;
            --orange: #ff8800;
            --blue: #4488ff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            min-height: 100vh;
            background: var(--bg);
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background-image:
                radial-gradient(ellipse 100% 80% at 50% 0%, rgba(0, 245, 255, 0.06), transparent 50%),
                radial-gradient(ellipse 60% 60% at 100% 100%, rgba(191, 0, 255, 0.04), transparent);
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 20px;
            letter-spacing: 0.2em;
            background: linear-gradient(135deg, var(--cyan), var(--purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-container {
            display: flex;
            gap: 24px;
            align-items: flex-start;
            padding: 24px;
            background: rgba(20, 20, 30, 0.8);
            border-radius: 16px;
            border: 1px solid var(--border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 60px rgba(0, 245, 255, 0.05);
        }

        .boards-row {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            position: relative;
        }

        .game-board {
            position: relative;
        }

        .player-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            color: var(--cyan);
            margin-bottom: 8px;
        }

        .opponent-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            color: var(--red);
            margin-bottom: 8px;
        }

        #tetrisOpponent {
            display: block;
            background: var(--grid);
            border: 3px solid var(--red);
            border-radius: 8px;
            box-shadow: inset 0 0 30px rgba(255, 51, 102, 0.08);
        }

        #tetris {
            display: block;
            background: var(--grid);
            border: 3px solid var(--cyan);
            border-radius: 8px;
            box-shadow: inset 0 0 30px rgba(0, 245, 255, 0.05);
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 24px;
            min-width: 140px;
        }

        .panel-box {
            background: var(--grid);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
        }

        .panel-box h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--cyan);
            margin-bottom: 12px;
        }

        .score-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--cyan);
        }

        .gold-display {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--yellow);
        }

        .gold-display::before {
            content: 'ü™ô';
            font-size: 1.4rem;
        }

        .shop-btn {
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            border: 2px solid var(--yellow);
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
            color: var(--yellow);
            transition: all 0.2s;
        }

        .shop-btn:hover {
            background: rgba(255, 234, 0, 0.15);
        }

        .shop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .shop-overlay.visible {
            display: flex;
        }

        .shop-modal {
            background: var(--grid);
            border: 2px solid var(--yellow);
            border-radius: 16px;
            padding: 28px;
            max-width: 420px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .shop-modal h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--yellow);
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .shop-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding: 14px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 10px;
            border: 1px solid var(--border);
        }

        .shop-item.info {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }

        .shop-item-name {
            font-weight: 600;
            color: #fff;
        }

        .shop-item-desc {
            font-size: 0.8rem;
            color: #888;
        }

        .shop-item-price {
            color: var(--yellow);
            font-weight: 600;
            white-space: nowrap;
        }

        .shop-item-price.not-enough {
            color: var(--red);
        }

        .shop-item-btn {
            padding: 8px 16px;
            font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            background: var(--yellow);
            color: var(--bg);
            transition: all 0.2s;
        }

        .shop-item-btn:hover:not(:disabled) {
            transform: scale(1.05);
        }

        .shop-item-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shop-item-btn.owned {
            background: var(--green);
            color: var(--bg);
        }

        .shop-close {
            margin-top: 16px;
            width: 100%;
            padding: 12px;
            background: var(--border);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
        }

        .inventory-hint {
            font-size: 0.7rem;
            color: #666;
            margin-top: 8px;
        }

        .active-items {
            margin-top: 8px;
            font-size: 0.75rem;
            color: var(--green);
        }

        #nextCanvas {
            display: block;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 4px;
        }

        .controls {
            margin-top: 20px;
            font-size: 0.75rem;
            color: #888;
            line-height: 1.8;
        }

        .controls kbd {
            display: inline-block;
            padding: 2px 6px;
            background: var(--border);
            border-radius: 4px;
            margin-right: 4px;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            gap: 16px;
        }

        .game-over.visible {
            display: flex;
        }

        .game-over h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--red);
        }

        .game-over .final-score {
            font-size: 1.2rem;
            color: var(--cyan);
        }

        .btn {
            padding: 12px 28px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(135deg, var(--cyan), var(--cyan-dim));
            color: var(--bg);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 245, 255, 0.4);
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            gap: 24px;
        }

        .start-screen.hidden {
            display: none;
        }

        .start-screen p {
            color: #888;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <h1>–¢–ï–¢–†–ò–°</h1>
    <div class="top-bar" style="display:flex; align-items:center; gap:24px; margin-bottom:16px;">
        <div class="gold-display" id="goldDisplay">0</div>
        <button class="shop-btn" onclick="toggleShop()">üõí –ú–∞–≥–∞–∑–∏–Ω</button>
        <button class="shop-btn" id="muteBtn" onclick="document.getElementById('muteBtn').innerHTML=(Sound.toggleMute()?'üîä –ó–≤—É–∫ –≤–∫–ª':'üîá –ó–≤—É–∫ –≤—ã–∫–ª')">üîá –ó–≤—É–∫</button>
        <span id="gamepadStatus" style="font-size:0.8rem;color:#666">üéÆ</span>
    </div>
    <div class="game-container">
        <div class="boards-row">
            <div class="game-board">
                <div class="opponent-label">ü§ñ –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ <span id="opponentScore" style="color:#888;font-size:0.65rem">0</span> ¬∑ –ü–æ–±–µ–¥—ã: <span id="defeatedCount" style="color:var(--green)">0</span></div>
                <canvas id="tetrisOpponent" width="300" height="600"></canvas>
            </div>
            <div class="game-board">
                <div class="player-label">üë§ –í—ã</div>
                <canvas id="tetris" width="300" height="600"></canvas>
            <div class="game-over" id="gameOver">
                <h2>–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</h2>
                <span class="final-score" id="finalScore">0</span>
                <button class="btn" onclick="restart()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
            </div>
            <div class="start-screen" id="startScreen">
                <p>–°—Ä–∞–∂–∞–π—Å—è –ø—Ä–æ—Ç–∏–≤ –ò–ò!</p>
                <p style="font-size:0.8rem">–û—á–∏—â–∞–π –ª–∏–Ω–∏–∏ ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–π –º—É—Å–æ—Ä –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫—É</p>
                <button class="btn" onclick="startGame()">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
            </div>
        </div>
        </div>
        <div class="side-panel">
            <div class="panel-box">
                <h3>–û—á–∫–∏</h3>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="panel-box">
                <h3>–£—Ä–æ–≤–µ–Ω—å</h3>
                <div class="score-value" id="level">1</div>
            </div>
            <div class="panel-box" id="holdPanel" style="display:none">
                <h3>–•–æ–ª–¥ <kbd>C</kbd></h3>
                <canvas id="holdCanvas" width="80" height="60"></canvas>
            </div>
            <div class="panel-box">
                <h3>–°–ª–µ–¥—É—é—â–∞—è</h3>
                <canvas id="nextCanvas" width="100" height="80"></canvas>
            </div>
            <div class="panel-box controls">
                <h3>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
                <div><kbd>‚Üê</kbd><kbd>‚Üí</kbd> –î–≤–∏–∂–µ–Ω–∏–µ</div>
                <div><kbd>‚Üì</kbd> –£—Å–∫–æ—Ä–∏—Ç—å</div>
                <div><kbd>‚Üë</kbd> –ü–æ–≤–æ—Ä–æ—Ç</div>
                <div><kbd>–ü—Ä–æ–±–µ–ª</kbd> –°–±—Ä–æ—Å–∏—Ç—å</div>
                <div><kbd>C</kbd> –•–æ–ª–¥ (–µ—Å–ª–∏ –∫—É–ø–ª–µ–Ω–æ)</div>
                <div><kbd>1</kbd> –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ</div>
                <div><kbd>2</kbd><kbd>B</kbd> –ë–æ–º–±–∞</div>
                <div><kbd>3</kbd> x2 –ó–æ–ª–æ—Ç–æ</div>
                <div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);color:#666;font-size:0.7rem">
                    <strong style="color:var(--cyan)">Xbox:</strong> –°—Ç–∏–∫–∏/–∫—Ä–µ—Å—Ç ‚Üê‚Üí –¥–≤–∏–∂–µ–Ω–∏–µ, A –ø–æ–≤–æ—Ä–æ—Ç, RT —Å–±—Ä–æ—Å, X —Ö–æ–ª–¥
                </div>
            </div>
        </div>
    </div>

    <div class="shop-overlay" id="shopOverlay" onclick="if(event.target===this)toggleShop()">
        <div class="shop-modal" onclick="event.stopPropagation()">
            <h2>üõí –ú–∞–≥–∞–∑–∏–Ω</h2>
            <p class="inventory-hint">–ó–æ–ª–æ—Ç–æ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –∑–∞ —Å–≥–æ—Ä–µ–≤—à–∏–µ –ª–∏–Ω–∏–∏. –°—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è ‚Äî –Ω–∞–≤—Å–µ–≥–¥–∞.</p>
            <div id="shopItems"></div>
            <button class="shop-close" onclick="toggleShop()">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <script>
        const Sound = (() => {
            let ctx = null;
            let muted = localStorage.getItem('tetris_muted') === '1';
            const play = (freq, duration, type = 'square', vol = 0.15) => {
                if (muted) return;
                if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (ctx.state === 'suspended') ctx.resume();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.value = freq;
                osc.type = type;
                gain.gain.setValueAtTime(vol, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + duration);
            };
            return {
                pieceLand: () => play(220, 0.05, 'square', 0.1),
                rotate: () => play(330, 0.03, 'square', 0.06),
                move: () => play(150, 0.02, 'square', 0.04),
                lineClear: () => play(440, 0.08, 'square', 0.12),
                tetris: () => { play(523, 0.1, 'square', 0.15); setTimeout(() => play(659, 0.1, 'square', 0.15), 80); setTimeout(() => play(784, 0.15, 'square', 0.15), 160); },
                levelUp: () => { play(392, 0.1, 'square', 0.12); setTimeout(() => play(523, 0.15, 'square', 0.12), 100); },
                gameOver: () => { play(150, 0.2, 'sawtooth', 0.2); setTimeout(() => play(100, 0.4, 'sawtooth', 0.15), 150); },
                win: () => { play(523, 0.1, 'square', 0.15); setTimeout(() => play(659, 0.1, 'square', 0.15), 100); setTimeout(() => play(784, 0.1, 'square', 0.15), 200); setTimeout(() => play(1047, 0.3, 'square', 0.15), 300); },
                hold: () => play(280, 0.04, 'square', 0.08),
                bomb: () => play(180, 0.12, 'sawtooth', 0.15),
                toggleMute: () => { muted = !muted; localStorage.setItem('tetris_muted', muted ? '1' : '0'); return muted; },
                isMuted: () => muted,
                unlock: () => { if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)(); if (ctx.state === 'suspended') ctx.resume(); }
            };
        })();

        const COLS = 10;
        const ROWS = 20;
        const BLOCK = 30;
        const COLORS = ['', '#00f5ff', '#ffea00', '#bf00ff', '#00ff88', '#ff3366', '#ff8800', '#4488ff', '#444466'];

        const SHAPES = [
            null,
            [[1,1,1,1]],
            [[2,2],[2,2]],
            [[0,3,0],[3,3,3]],
            [[0,4,4],[4,4,0]],
            [[5,5,0],[0,5,5]],
            [[6,0,0],[6,6,6]],
            [[0,0,7],[7,7,7]]
        ];

        const SHOP_ITEMS = [
            { id: 'ghost', name: 'üëª –ü—Ä–∏–∑—Ä–∞–∫', desc: '–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–µ–Ω—å, –∫—É–¥–∞ —É–ø–∞–¥—ë—Ç —Ñ–∏–≥—É—Ä–∞', price: 100, type: 'upgrade', key: 'ghost' },
            { id: 'hold', name: 'üì¶ –•–æ–ª–¥', desc: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∏–≥—É—Ä—É –Ω–∞ –ø–æ—Ç–æ–º (C)', price: 150, type: 'upgrade', key: 'hold' },
            { id: 'slow', name: 'üê¢ –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ', desc: '20 —Å–µ–∫ –º–µ–¥–ª–µ–Ω–Ω–µ–µ –ø–∞–¥–µ–Ω–∏–µ', price: 80, type: 'consumable', key: 'slow' },
            { id: 'bomb', name: 'üí£ –ë–æ–º–±–∞', desc: '–û—á–∏—Å—Ç–∏—Ç—å —Å–ª—É—á–∞–π–Ω—ã–π –ø–æ–ª–Ω—ã–π —Ä—è–¥ (B)', price: 60, type: 'consumable', key: 'bomb' },
            { id: 'doubleGold', name: 'üí∞ x2 –ó–æ–ª–æ—Ç–æ', desc: '–í–¥–≤–æ–µ –±–æ–ª—å—à–µ –∑–æ–ª–æ—Ç–∞ –∑–∞ 3 –ª–∏–Ω–∏–∏', price: 100, type: 'consumable', key: 'doubleGold' },
            { id: 'extraLife', name: '‚ù§Ô∏è –í—Ç–æ—Ä–∞—è –∂–∏–∑–Ω—å', desc: '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ—Å–ª–µ –ø—Ä–æ–∏–≥—Ä—ã—à–∞ (1 —Ä–∞–∑)', price: 200, type: 'consumable', key: 'extraLife' }
        ];

        let canvas, ctx, nextCanvas, nextCtx, holdCanvas, holdCtx;
        let oppCanvas, oppCtx;
        let board = [];
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameOver = false;
        let gameStarted = false;
        let dropInterval = 1000;
        let lastDrop = 0;
        let currentPiece = null;
        let heldPiece = null;
        let canHold = true;
        let animationId = null;

        let gold = parseInt(localStorage.getItem('tetris_gold'));
        if (isNaN(gold)) { gold = 50; localStorage.setItem('tetris_gold', '50'); }
        let upgrades = JSON.parse(localStorage.getItem('tetris_upgrades')) || { ghost: false, hold: false };
        let consumables = JSON.parse(localStorage.getItem('tetris_consumables')) || { slow: 0, bomb: 0, doubleGold: 0, extraLife: 0 };
        let doubleGoldLinesLeft = 0;
        let usedExtraLife = false;

        let opponentBoard = [];
        let opponentPiece = null;
        let opponentScore = 0;
        let opponentLastDrop = 0;
        let opponentDropInterval = 1200;
        let opponentGameOver = false;
        let opponentPendingGarbage = 0;
        let playerPendingGarbage = 0;
        let sharedPieceBag = [];
        let defeatedCount = 0;
        let sharedPieceForRound = null;
        let pieceConsumedByPlayer = false;
        let pieceConsumedByOpponent = false;

        let gpPrevButtons = [];
        let gpPrevAxes = [];
        let gpMoveCooldown = 0;

        function handleGamepad() {
            const pads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = pads[0];
            if (!gp || !gp.connected) return;

            const THRESH = 0.5;
            const btn = (i) => (gp.buttons[i] && gp.buttons[i].pressed) || (typeof gp.buttons[i] === 'number' && gp.buttons[i] > THRESH);
            const axis = (i) => gp.axes[i] || 0;

            if (!gameStarted && (btn(9) || btn(0))) { startGame(); return; }
            if (gameOver && (btn(9) || btn(0))) { restart(); return; }
            if (!gameStarted || gameOver) return;

            if (btn(0)) { if (!gpPrevButtons[0]) { rotate(); gpPrevButtons[0] = true; } } else gpPrevButtons[0] = false;
            if (btn(2)) { if (!gpPrevButtons[2]) { holdPiece(); gpPrevButtons[2] = true; } } else gpPrevButtons[2] = false;
            if (btn(3) || btn(7)) { if (!gpPrevButtons[3] && !gpPrevButtons[7]) { hardDrop(); gpPrevButtons[3] = gpPrevButtons[7] = true; } } else { gpPrevButtons[3] = false; gpPrevButtons[7] = false; }
            if (btn(1)) { if (!gpPrevButtons[1] && consumables.bomb > 0) { useConsumable('bomb'); gpPrevButtons[1] = true; } } else gpPrevButtons[1] = false;
            if (btn(4)) { if (!gpPrevButtons[4] && consumables.slow > 0) { useConsumable('slow'); gpPrevButtons[4] = true; } } else gpPrevButtons[4] = false;
            if (btn(5)) { if (!gpPrevButtons[5] && consumables.doubleGold > 0) { useConsumable('doubleGold'); gpPrevButtons[5] = true; } } else gpPrevButtons[5] = false;

            const axH = axis(0), axV = axis(1);
            const dpadH = gp.axes[6] || 0, dpadV = gp.axes[7] || 0;
            const dpadL = (gp.buttons[14] && (gp.buttons[14].pressed || (gp.buttons[14].value || 0) > THRESH));
            const dpadR = (gp.buttons[15] && (gp.buttons[15].pressed || (gp.buttons[15].value || 0) > THRESH));
            const dpadD = (gp.buttons[13] && (gp.buttons[13].pressed || (gp.buttons[13].value || 0) > THRESH));
            const left = axH < -THRESH || dpadH < -THRESH || dpadL;
            const right = axH > THRESH || dpadH > THRESH || dpadR;
            const down = axV > THRESH || dpadV > THRESH || dpadD;

            if (gpMoveCooldown <= 0) {
                if (left) { move(-1); gpMoveCooldown = 120; }
                else if (right) { move(1); gpMoveCooldown = 120; }
                if (down) drop();
            } else gpMoveCooldown -= 16;
        }

        function getNextSharedPiece() {
            if (sharedPieceBag.length === 0) {
                const types = [1, 2, 3, 4, 5, 6, 7];
                for (let i = types.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [types[i], types[j]] = [types[j], types[i]];
                }
                sharedPieceBag = types.map(t => ({ shape: SHAPES[t].map(row => [...row]), type: t }));
            }
            return sharedPieceBag.pop();
        }

        function init() {
            canvas = document.getElementById('tetris');
            ctx = canvas.getContext('2d');
            nextCanvas = document.getElementById('nextCanvas');
            nextCtx = nextCanvas.getContext('2d');
            holdCanvas = document.getElementById('holdCanvas');
            holdCtx = holdCanvas.getContext('2d');
            oppCanvas = document.getElementById('tetrisOpponent');
            oppCtx = oppCanvas.getContext('2d');
            document.getElementById('holdPanel').style.display = upgrades.hold ? 'block' : 'none';

            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) board[r][c] = 0;
            }

            document.addEventListener('keydown', handleKey);
            document.getElementById('tetris').addEventListener('click', () => {
                if (!gameStarted) startGame();
            });
            document.getElementById('muteBtn').innerHTML = Sound.isMuted() ? 'üîä –ó–≤—É–∫ –≤–∫–ª' : 'üîá –ó–≤—É–∫ –≤—ã–∫–ª';
            updateGold();
            renderShop();
            setInterval(handleGamepad, 50);
            const updGpStatus = () => {
                const el = document.getElementById('gamepadStatus');
                const gp = navigator.getGamepads ? navigator.getGamepads()[0] : null;
                el.textContent = gp && gp.connected ? 'üéÆ Xbox –ø–æ–¥–∫–ª—é—á–µ–Ω' : 'üéÆ';
                el.style.color = gp && gp.connected ? 'var(--green)' : '#666';
            };
            window.addEventListener('gamepadconnected', updGpStatus);
            window.addEventListener('gamepaddisconnected', updGpStatus);
            setInterval(updGpStatus, 1000);
        }

        function addGold(amount) {
            const mult = doubleGoldLinesLeft > 0 ? 2 : 1;
            gold += Math.floor(amount * mult);
            if (doubleGoldLinesLeft > 0) doubleGoldLinesLeft--;
            localStorage.setItem('tetris_gold', gold.toString());
            updateGold();
        }

        function updateGold() {
            document.getElementById('goldDisplay').textContent = gold;
        }

        function saveUpgrades() {
            localStorage.setItem('tetris_upgrades', JSON.stringify(upgrades));
        }

        function toggleShop() {
            const el = document.getElementById('shopOverlay');
            el.classList.toggle('visible');
            if (el.classList.contains('visible')) renderShop();
        }

        function buyItem(item) {
            if (gold < item.price) return;
            if (item.type === 'upgrade' && upgrades[item.key]) return;
            gold -= item.price;
            localStorage.setItem('tetris_gold', gold.toString());
            if (item.type === 'upgrade') {
                upgrades[item.key] = true;
                saveUpgrades();
                if (item.key === 'hold') document.getElementById('holdPanel').style.display = 'block';
            } else {
                consumables[item.key]++;
                localStorage.setItem('tetris_consumables', JSON.stringify(consumables));
            }
            updateGold();
            renderShop();
        }

        function useConsumable(key) {
            if (consumables[key] <= 0) return;
            consumables[key]--;
            if (key === 'slow') {
                dropInterval = Math.min(1200, dropInterval + 400);
                setTimeout(() => {
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                }, 20000);
            } else if (key === 'bomb') {
                Sound.bomb();
                const fullRows = [];
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r].every(c => c !== 0)) fullRows.push(r);
                }
                if (fullRows.length > 0) {
                    const r = fullRows[Math.floor(Math.random() * fullRows.length)];
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    addGold(15);
                }
            } else if (key === 'doubleGold') {
                doubleGoldLinesLeft = 3;
            }
            localStorage.setItem('tetris_consumables', JSON.stringify(consumables));
            renderShop();
        }

        function renderShop() {
            const container = document.getElementById('shopItems');
            container.innerHTML = SHOP_ITEMS.map(item => {
                const isUpgrade = item.type === 'upgrade';
                const owned = isUpgrade ? upgrades[item.key] : false;
                const count = !isUpgrade ? consumables[item.key] : 0;
                const canBuy = gold >= item.price && (!owned || !isUpgrade);
                return `
                    <div class="shop-item">
                        <div>
                            <div class="shop-item-name">${item.name}</div>
                            <div class="shop-item-desc">${item.desc}</div>
                            ${count > 0 ? `<div class="active-items">–í –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ: ${count}</div>` : ''}
                        </div>
                        <div style="display:flex;align-items:center;gap:12px;">
                            <span class="shop-item-price ${gold < item.price ? 'not-enough' : ''}">ü™ô ${item.price}</span>
                            <button class="shop-item-btn ${owned ? 'owned' : ''}" 
                                data-item-id="${item.id}"
                                ${!canBuy || owned ? 'disabled' : ''}>
                                ${owned ? '‚úì –ï—Å—Ç—å' : count > 0 && !isUpgrade ? '–ö—É–ø–∏—Ç—å –µ—â—ë' : '–ö—É–ø–∏—Ç—å'}
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            container.querySelectorAll('button[data-item-id]').forEach(btn => {
                btn.onclick = () => {
                    const item = SHOP_ITEMS.find(i => i.id === btn.dataset.itemId);
                    if (item) buyItem(item);
                };
            });
        }

        function startGame() {
            if (gameStarted) return;
            Sound.unlock();
            document.getElementById('startScreen').classList.add('hidden');
            gameStarted = true;
            gameOver = false;
            score = 0;
            level = 1;
            lines = 0;
            dropInterval = 1000;
            heldPiece = null;
            canHold = true;
            usedExtraLife = false;
            doubleGoldLinesLeft = 0;
            const saved = localStorage.getItem('tetris_consumables');
            if (saved) consumables = JSON.parse(saved);

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) board[r][c] = 0;
            }

            opponentBoard = [];
            for (let r = 0; r < ROWS; r++) {
                opponentBoard[r] = [];
                for (let c = 0; c < COLS; c++) opponentBoard[r][c] = 0;
            }
            opponentPiece = null;
            sharedPieceForRound = null;
            pieceConsumedByPlayer = false;
            pieceConsumedByOpponent = false;
            opponentScore = 0;
            opponentGameOver = false;
            opponentDropInterval = 1200;
            opponentLastDrop = 0;
            opponentPendingGarbage = 0;
            playerPendingGarbage = 0;
            sharedPieceBag = [];
            defeatedCount = 0;
            document.getElementById('opponentScore').textContent = '0';
            document.getElementById('defeatedCount').textContent = '0';

            updateScore();
            updateLevel();
            drawHold();
            spawnPiece();
            spawnOpponentPiece();
            requestAnimationFrame(gameLoop);
        }

        function restart() {
            document.getElementById('gameOver').classList.remove('visible');
            gameStarted = false;
            startGame();
        }

        function createPiece() {
            const type = Math.floor(Math.random() * 7) + 1;
            return {
                shape: SHAPES[type].map(row => [...row]),
                type
            };
        }

        function getSharedPiece() {
            if (!sharedPieceForRound) {
                sharedPieceForRound = getNextSharedPiece();
                pieceConsumedByPlayer = false;
                pieceConsumedByOpponent = false;
            }
            const piece = { ...sharedPieceForRound, shape: sharedPieceForRound.shape.map(r => [...r]) };
            return piece;
        }

        function advanceSharedPiece() {
            pieceConsumedByPlayer = false;
            pieceConsumedByOpponent = false;
            sharedPieceForRound = getNextSharedPiece();
        }

        function spawnPiece() {
            if (playerPendingGarbage > 0) {
                addGarbageToBoard(board, playerPendingGarbage);
                playerPendingGarbage = 0;
            }
            canHold = true;
            currentPiece = getSharedPiece();
            pieceConsumedByPlayer = true;
            if (pieceConsumedByOpponent) advanceSharedPiece();
            drawNext();
            currentPiece.x = Math.floor(COLS / 2) - Math.ceil(currentPiece.shape[0].length / 2);
            currentPiece.y = 0;

            if (collision(currentPiece)) {
                endGame();
            }
        }

        function opponentCollision(piece, offX = 0, offY = 0, b = opponentBoard) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (piece.shape[r][c]) {
                        const ny = piece.y + r + offY;
                        const nx = piece.x + c + offX;
                        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
                        if (ny >= 0 && b[ny][nx]) return true;
                    }
                }
            }
            return false;
        }

        function addGarbageToBoard(targetBoard, count) {
            for (let g = 0; g < count; g++) {
                const hole = Math.floor(Math.random() * COLS);
                for (let r = 0; r < ROWS - 1; r++) targetBoard[r] = targetBoard[r + 1].slice();
                targetBoard[ROWS - 1] = Array(COLS).fill(8);
                targetBoard[ROWS - 1][hole] = 0;
            }
        }

        function spawnOpponentPiece() {
            if (opponentPendingGarbage > 0) {
                addGarbageToBoard(opponentBoard, opponentPendingGarbage);
                opponentPendingGarbage = 0;
            }
            opponentPiece = getSharedPiece();
            pieceConsumedByOpponent = true;
            if (pieceConsumedByPlayer) advanceSharedPiece();
            opponentPiece.x = Math.floor(COLS / 2) - Math.ceil(opponentPiece.shape[0].length / 2);
            opponentPiece.y = 0;
            if (opponentCollision(opponentPiece)) {
                defeatedCount++;
                document.getElementById('defeatedCount').textContent = defeatedCount;
                Sound.win();
                for (let r = ROWS - 1; r >= 0; r--) {
                    const row = board[r];
                    if (row.some(c => c === 8) && row.every(c => c === 0 || c === 8)) {
                        board.splice(r, 1);
                        board.unshift(Array(COLS).fill(0));
                        r++;
                    }
                }
                for (let r = 0; r < ROWS; r++) {
                    opponentBoard[r] = [];
                    for (let c = 0; c < COLS; c++) opponentBoard[r][c] = 0;
                }
                opponentScore = 0;
                opponentPendingGarbage = 0;
                opponentGameOver = false;
                document.getElementById('opponentScore').textContent = '0';
                spawnOpponentPiece();
            }
        }

        function getBestOpponentMove() {
            let bestScore = -1e9, bestX = 0, bestRot = 0;
            for (let rot = 0; rot < 4; rot++) {
                const shape = [...Array(rot)].reduce(s => 
                    s[0].map((_, i) => s.map(r => r[i]).reverse()), opponentPiece.shape.map(r => [...r]));
                for (let x = 0; x <= COLS - shape[0].length; x++) {
                    const piece = { ...opponentPiece, x, y: 0, shape: shape.map(r => [...r]) };
                    let dy = 0;
                    while (!opponentCollision(piece, 0, dy + 1)) dy++;
                    piece.y += dy;
                    if (piece.y < 0) continue;
                    const simBoard = opponentBoard.map(r => r.slice());
                    for (let rr = 0; rr < piece.shape.length; rr++)
                        for (let cc = 0; cc < piece.shape[rr].length; cc++)
                            if (piece.shape[rr][cc] && piece.y + rr >= 0)
                                simBoard[piece.y + rr][piece.x + cc] = piece.shape[rr][cc];
                    let cleared = 0;
                    for (let rr = ROWS - 1; rr >= 0; rr--) {
                        if (simBoard[rr].every(c => c !== 0)) { cleared++; simBoard.splice(rr, 1); simBoard.unshift(Array(COLS).fill(0)); rr++; }
                    }
                    let maxH = 0;
                    for (let cc = 0; cc < COLS; cc++)
                        for (let rr = 0; rr < ROWS; rr++)
                            if (simBoard[rr][cc]) { maxH = Math.max(maxH, ROWS - rr); break; }
                    const score = cleared * 500 - maxH * 2;
                    if (score > bestScore) { bestScore = score; bestX = x; bestRot = rot; }
                }
            }
            return { x: bestX, rot: bestRot };
        }

        function executeOpponentMove() {
            if (!opponentPiece || opponentGameOver) return;
            const { x, rot } = getBestOpponentMove();
            for (let i = 0; i < rot; i++)
                opponentPiece.shape = opponentPiece.shape[0].map((_, j) => opponentPiece.shape.map(r => r[j]).reverse());
            opponentPiece.x = x;
            let dy = 0;
            while (!opponentCollision(opponentPiece, 0, dy + 1)) dy++;
            opponentPiece.y += dy;
            for (let r = 0; r < opponentPiece.shape.length; r++)
                for (let c = 0; c < opponentPiece.shape[r].length; c++)
                    if (opponentPiece.shape[r][c] && opponentPiece.y + r >= 0)
                        opponentBoard[opponentPiece.y + r][opponentPiece.x + c] = opponentPiece.shape[r][c];
            let cleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (opponentBoard[r].every(cell => cell !== 0)) {
                    opponentBoard.splice(r, 1);
                    opponentBoard.unshift(Array(COLS).fill(0));
                    cleared++;
                    r++;
                }
            }
            if (cleared > 0) {
                opponentScore += [0, 100, 300, 500, 800][cleared] || 800;
                playerPendingGarbage += cleared;
                document.getElementById('opponentScore').textContent = opponentScore;
            }
            spawnOpponentPiece();
        }

        function collision(piece, offX = 0, offY = 0) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (piece.shape[r][c]) {
                        const ny = piece.y + r + offY;
                        const nx = piece.x + c + offX;
                        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
                        if (ny >= 0 && board[ny][nx]) return true;
                    }
                }
            }
            return false;
        }

        function merge() {
            Sound.pieceLand();
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (currentPiece.shape[r][c]) {
                        const y = currentPiece.y + r;
                        const x = currentPiece.x + c;
                        if (y >= 0) board[y][x] = currentPiece.shape[r][c];
                    }
                }
            }
        }

        function clearLines() {
            let cleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    cleared++;
                    r++;
                }
            }
            if (cleared > 0) {
                if (cleared === 4) Sound.tetris(); else Sound.lineClear();
                const points = [0, 100, 300, 500, 800];
                score += (points[cleared] || 800) * level;
                const goldReward = [0, 5, 15, 30, 50][cleared] || 50;
                addGold(goldReward);
                opponentPendingGarbage += cleared;
                lines += cleared;
                if (lines >= level * 10) {
                    level++;
                    Sound.levelUp();
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                    updateLevel();
                }
                updateScore();
            }
        }

        function rotate() {
            if (!currentPiece || gameOver) return;
            Sound.rotate();
            const rotated = currentPiece.shape[0].map((_, i) =>
                currentPiece.shape.map(row => row[i]).reverse()
            );
            const prev = currentPiece.shape;
            currentPiece.shape = rotated;
            if (collision(currentPiece)) currentPiece.shape = prev;
        }

        function move(dir) {
            if (!currentPiece || gameOver) return;
            if (!collision(currentPiece, dir, 0)) {
                currentPiece.x += dir;
            }
        }

        function drop() {
            if (!currentPiece || gameOver) return;
            if (!collision(currentPiece, 0, 1)) {
                currentPiece.y++;
                score += 2 * level;
                updateScore();
            } else {
                merge();
                clearLines();
                spawnPiece();
            }
        }

        function hardDrop() {
            if (!currentPiece || gameOver) return;
            while (!collision(currentPiece, 0, 1)) {
                currentPiece.y++;
                score += 4 * level;
            }
            merge();
            clearLines();
            spawnPiece();
        }

        function holdPiece() {
            if (!upgrades.hold || !currentPiece || !canHold || gameOver) return;
            if (heldPiece) {
                const tmp = heldPiece;
                heldPiece = { ...currentPiece, shape: currentPiece.shape.map(r => [...r]) };
                currentPiece = tmp;
                currentPiece.x = Math.floor(COLS / 2) - Math.ceil(currentPiece.shape[0].length / 2);
                currentPiece.y = 0;
            } else {
                heldPiece = { ...currentPiece, shape: currentPiece.shape.map(r => [...r]) };
                currentPiece = getSharedPiece();
                pieceConsumedByPlayer = true;
                if (pieceConsumedByOpponent) advanceSharedPiece();
                drawNext();
                currentPiece.x = Math.floor(COLS / 2) - Math.ceil(currentPiece.shape[0].length / 2);
                currentPiece.y = 0;
            }
            canHold = false;
            Sound.hold();
            drawHold();
        }

        function handleKey(e) {
            if (!gameStarted && e.code !== 'Space') return;
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameStarted) startGame();
                else hardDrop();
            }
            if (!gameStarted || gameOver) return;
            switch (e.code) {
                case 'ArrowLeft': e.preventDefault(); move(-1); break;
                case 'ArrowRight': e.preventDefault(); move(1); break;
                case 'ArrowDown': e.preventDefault(); drop(); break;
                case 'ArrowUp': e.preventDefault(); rotate(); break;
                case 'KeyC': e.preventDefault(); holdPiece(); break;
                case 'Digit1': if (consumables.slow > 0) useConsumable('slow'); break;
                case 'Digit2': if (consumables.bomb > 0) useConsumable('bomb'); break;
                case 'Digit3': if (consumables.doubleGold > 0) useConsumable('doubleGold'); break;
                case 'KeyB': if (consumables.bomb > 0) { e.preventDefault(); useConsumable('bomb'); } break;
            }
        }

        function drawBlock(ctx, x, y, color, size = BLOCK) {
            const gap = 1;
            ctx.fillStyle = color;
            ctx.fillRect(x * size + gap, y * size + gap, size - gap * 2, size - gap * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(x * size + gap, y * size + gap, size - gap * 2, 4);
        }

        function getGhostY() {
            if (!currentPiece) return 0;
            let dy = 0;
            while (!collision(currentPiece, 0, dy + 1)) dy++;
            return currentPiece.y + dy;
        }

        function drawBlock(ctx, x, y, color, size = BLOCK, alpha = 1) {
            const gap = 1;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.fillRect(x * size + gap, y * size + gap, size - gap * 2, size - gap * 2);
            if (alpha >= 0.9) {
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(x * size + gap, y * size + gap, size - gap * 2, 4);
            }
            ctx.restore();
        }

        function draw() {
            ctx.fillStyle = '#1a1a24';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawBlock(ctx, c, r, COLORS[board[r][c]]);
                    }
                }
            }

            if (currentPiece) {
                if (upgrades.ghost) {
                    const ghostY = getGhostY();
                    for (let r = 0; r < currentPiece.shape.length; r++) {
                        for (let c = 0; c < currentPiece.shape[r].length; c++) {
                            if (currentPiece.shape[r][c]) {
                                drawBlock(ctx, currentPiece.x + c, ghostY + r, COLORS[currentPiece.shape[r][c]], BLOCK, 0.25);
                            }
                        }
                    }
                }
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c]) {
                            drawBlock(ctx, currentPiece.x + c, currentPiece.y + r, COLORS[currentPiece.shape[r][c]]);
                        }
                    }
                }
            }
        }

        function drawNext() {
            nextCtx.fillStyle = 'rgba(0,0,0,0.3)';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            const p = sharedPieceForRound;
            if (!p) return;
            const padX = (5 - p.shape[0].length) / 2;
            const padY = (4 - p.shape.length) / 2;
            for (let r = 0; r < p.shape.length; r++) {
                for (let c = 0; c < p.shape[r].length; c++) {
                    if (p.shape[r][c]) {
                        drawBlock(nextCtx, padX + c, padY + r, COLORS[p.shape[r][c]], 20);
                    }
                }
            }
        }

        function drawHold() {
            if (!holdCtx) return;
            holdCtx.fillStyle = 'rgba(0,0,0,0.3)';
            holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
            if (!heldPiece) return;
            const padX = (4 - heldPiece.shape[0].length) / 2;
            const padY = (3 - heldPiece.shape.length) / 2;
            for (let r = 0; r < heldPiece.shape.length; r++) {
                for (let c = 0; c < heldPiece.shape[r].length; c++) {
                    if (heldPiece.shape[r][c]) {
                        drawBlock(holdCtx, padX + c, padY + r, COLORS[heldPiece.shape[r][c]], 18);
                    }
                }
            }
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        function updateLevel() {
            document.getElementById('level').textContent = level;
        }

        function endGame() {
            if (consumables.extraLife > 0 && !usedExtraLife) {
                usedExtraLife = true;
                consumables.extraLife--;
                localStorage.setItem('tetris_consumables', JSON.stringify(consumables));
                renderShop();
                for (let r = 0; r < 6; r++) board[r] = Array(COLS).fill(0);
                return;
            }
            gameOver = true;
            Sound.gameOver();
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').classList.add('visible');
        }

        function drawOpponent() {
            if (!oppCtx) return;
            oppCtx.fillStyle = '#1a1a24';
            oppCtx.fillRect(0, 0, oppCanvas.width, oppCanvas.height);
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (opponentBoard[r][c]) {
                        drawBlock(oppCtx, c, r, COLORS[opponentBoard[r][c]] || '#555');
                    }
                }
            }
            if (opponentPiece && !opponentGameOver) {
                for (let r = 0; r < opponentPiece.shape.length; r++) {
                    for (let c = 0; c < opponentPiece.shape[r].length; c++) {
                        if (opponentPiece.shape[r][c]) {
                            drawBlock(oppCtx, opponentPiece.x + c, opponentPiece.y + r, COLORS[opponentPiece.shape[r][c]]);
                        }
                    }
                }
            }
        }

        function gameLoop(timestamp) {
            if (gameOver || !gameStarted) return;
            if (timestamp - lastDrop > dropInterval) {
                drop();
                lastDrop = timestamp;
            }
            if (!opponentGameOver && timestamp - opponentLastDrop > opponentDropInterval) {
                executeOpponentMove();
                opponentLastDrop = timestamp;
            }
            draw();
            drawOpponent();
            animationId = requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>
</html>
